### 代码审查：筛选与计数

#### 后端

* `get_all_properties_from_db` 为数据查询和计数分别维护 `params_data` 与 `params_count`，条件稍有修改就可能不同步；可考虑复用同一参数对象并派生出 count 查询
* `sort_direction` 直接插入到 `ORDER BY` 语句中，虽然当前只接受 `"ASC"`/`"DESC"`，仍应做白名单验证以防 SQL 注入
* `get_direct_walk_properties_crud` 使用映射表生成动态 WHERE 片段并分别执行 count 与数据查询，结构清晰，但若 `filters` 传入未在 `valid_filters_map` 中的键会被静默忽略，可返回提示或抛出异常
* 主查询 `get_properties` 通过拼接字符串构建多值筛选（如 `bedrooms`/`bathrooms`），缺乏统一的参数化机制，建议引入辅助函数生成 `OR` 子句并保持参数数组与条件列表的一致性

#### 前端数据层

* `getFilteredCount` 与 `getPreviewCount` 合并已应用参数和草稿参数后再请求后端，逻辑完善；但每次计数都要根据邮编展开 suburb，成本较高，建议缓存 `areasList` 或在后端处理映射
* 错误时 `getFilteredCount` 和 `getPreviewCount` 直接返回 `0`，前端难以区分“无结果”与“请求失败”，可改为返回 `null` 或抛出异常以便 UI 有针对性反馈

#### 前端筛选面板

* 多个面板（价格、卧室、时间、更多、区域）都实现了 `_countSeq + setTimeout` 的防抖计数策略，能避免并发响应错位，但未在组件卸载时清理 `_countTimer`，可能造成内存泄漏；建议在 `onUnmounted` 中统一 `clearTimeout`
* 各面板 `computePreviewCount` 逻辑高度相似（更新草稿、请求 `getPreviewCount`、防抖），可抽取成可复用的 composable 以减少重复并统一行为{line_range_start=115 line_range_end=233 terminal_chunk_id=同上引用】
* 区域面板在移除或新增选项后立即触发计数，但 `AreasSelector` 可能频繁触发 `requestCount`，可增加最小输入间隔或合并更新以减轻 API 压力【F:vue-frontend/src/components/filter-panels/AreaFilterPanel.vue}

#### 其它

* `production-server.js` 在 Node 层对 GraphQL 返回的列表再次过滤与计数，逻辑简单但会重复前端/后端的筛选，建议直接在后端查询时完成过滤以减轻 Node 侧负担

### 总体建议

1. 统一后端筛选参数构建，避免数据/计数查询条件漂移。
2. 对排序与动态 SQL 变量做严格白名单校验。
3. 在前端抽象公共的“防抖计数 + 草稿合并”逻辑，并确保定时器在卸载时清理。
4. 计数接口在失败时应返回可区分的状态以提升可观测性。
5. 若 Node 层需要过滤，应考虑在后端提供相应的 GraphQL 参数，减少重复处理。
