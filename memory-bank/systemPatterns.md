# 系统设计模式与最佳实践

---

## 核心架构原则

### 数据流架构 (Data Flow Architecture)
```bash
# 核心数据流路径 (必须遵守)
Browser (Vue @ :5173) → Vite Proxy → Python Backend (@ :8000)
```

**禁止** ❌: AI Agent直接调用前端或其他反向依赖
**原因**: 引入脆弱中间层，增加延迟，隐藏真正的错误源

---

## 前端架构

- **组件框架**: Vue 3 (Composition API)
- **状态管理**: Pinia (单一数据源原则)
- **路由系统**: Vue Router (SPA架构)
- **UI库**: Element Plus (JUWO主题定制)

---

## CSS与布局模式

### 1. 样式作用域
**模式** ✅: 将布局影响的CSS规则 (`overflow`, `position`, `display`) 限定在组件作用域内
**反模式** ❌: 对顶级元素 (`body`, `html`) 应用全局 `overflow-x: hidden`

### 2. 布局对齐策略
**模式** ✅: 统一 `max-width: 1200px` 和 `padding: 0 32px` 确保垂直对齐
**反模式** ❌: 不同容器的对齐方式不一致

### 3. 全宽内容设计
**模式** ✅: 双层结构实现：
- 外层容器: `width: 100%` (背景)
- 内层容器: 居中内容区

---

## 状态管理原则

**单一数据源**: 组件负责触发action，业务逻辑在store actions中处理

**反模式** ❌: 在action中混合传入参数和未同步的旧state

---

## 移动端响应式模式

### 1. 渐进式间距系统
匀速递增的间距级别：`8px → 12px → 16px`
从核心元素到区域再到容器的视觉层次递增

### 2. 移动端滚动逻辑隔离
桌面端 vs 移动端使用不同的滚动判断机制：
- **桌面端**: `getBoundingClientRect()` 视窗位置判断
- **移动端**: `offsetHeight` 实际DOM高度判断

### 3. 性能优化的高度计算策略
使用缓存的DOM高度信息而非实时计算，以避免强制布局重计算

---

## 经验教训总结

- **CSS全局影响**: 全局 `overflow-x: hidden` 会破坏 `position: sticky`
- **滚动判断差异**: 移动端和桌面端需要隔离的滚动处理逻辑
- **布局统一**: 容器对齐不一致会导致视觉错位
- **状态同步**: 异步action中参数与state的不一致会导致数据错误

---

## API 设计与契约一致性（新增）

- 原则：相同资源的列表端点与详情端点必须返回一致的字段集合，详情端点应为列表端点的“超集”（superset），避免刷新或直链访问出现字段缺失导致的 UI 回退。
- 案例：`inspection_times` 需同时出现在 `/api/properties` 与 `/api/properties/{id}`。此次问题根因即为详情端点缺失该字段。
- 约束：
  - 新增字段时，优先在详情端点补齐，再在列表端点评估是否需要（考虑有效负载与性能）。
  - 任何字段移除/更名，必须通过后端兼容层或版本化保证向后兼容。
  - 启用缓存（FastAPI Cache/Redis）时，更新接口契约后应提供选择性失效端点，避免旧缓存长期污染响应。
- 实施建议：
  - 在后端添加契约单元测试/契约快照测试，校验两个端点的字段一致性（至少对关键字段如 `inspection_times`）。
  - 在 PR 审查清单中加入“端点字段一致性检查”项。
